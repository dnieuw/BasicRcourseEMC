
**Authors: Sten Willemsen, Karl Brand and Elizabeth Ribble**


# Objects in R

## Introduction

All the things we work with in R (such as the numbers in the calculations in the previous section) are called **objects**. All objects have a **mode** and a **class**. The **mode** describes how the data is stored in **R** and how it can be used. Text variables for example have to be handled differently than numbers, we cannot multiply two words. 

Elementary objects can be combined with each other to form more complex objects this leads to several types of containers, like `lists` and `data.frames`

The **class** of an object is an attribute that can be used to further specify how an object is used in **R**. For example it can be used to indicate how it should be printed and plotted. For many objects the class will simply be equal to the mode.

Functions are special objects that can do things with other objectsl, for example the `print` function displays the contents of an object in the console. Functions are the topic of an other chapter but because we obviously want to do something with the various objects we will see we cannot avoid them altogether.

## The elementary data types

The simplest variables just have a single value of a certain data type (Or mode^[`mode`, `storage.mode` and `type` are closely related concepts, we will not discuss the differences here. See also `?mode`.]). The most important data types in R are:^[There are a few more like `complex` and `raw`
 which we will not discuss.]: 

------------    ---------------------------------------------------
        mode    description
------------    ---------------------------------------------------    
    numeric:    Posibly fractional numerical values like 1.0, 1.2 or 1e12 (that is 10 raised to the power of 12)
  character:    text, for example 'man', 'woman', 'censored', etc. 
    logical:    TRUE and FALSE
-------------------------------------------------------------------

Let's examine variables of these data types in a bit more detail:

### Numbers
```{r}
mode(1)    
# for most basic data types the class is the same as the mode
class(1)    


class(2.14)
# functions that start with as.* do conversion
an_integer <- as.integer(2.14)
# integers are special numeric values that only store whole 
# numbers
an_integer 
class(an_integer)
mode(an_integer)
# convert to numeric again
back_to_numeric <- as.numeric(an_integer)
class(back_to_numeric)

class(1L) # explicit integer
```

### Text
```{r}
# character values should be surrounded by quotes "or '
class("a")
class('a')
mode("a")
# even numbers in quotes are interpreted as text
class("1")
mode("1")
```

### Logical
It can only be a **yes** or a **no**. More specifically, a `TRUE` or a `FALSE`.
```{r}
class(TRUE)
class(FALSE)
mode(TRUE)
```

Often logical values are he result of comparisons:

| Operator | Meaning                  |
|----------|--------------------------|
| ==       | Equal to                 |
| !=       | Not equal to             |
| >        | Greater than             |
| <        | Smaller than             |
| >=       | Greater than or equal to |
| <=       | Smaller than or equal to |

Logival values can be combined using `&` (and) and `|` or, and inverted using `!` (not).

```{r}
a <- c(TRUE, TRUE, FALSE, FALSE)
b <- c(TRUE, FALSE, TRUE, FALSE)

a & b
a | b
!a
```


## Vectors

Vectors of these data types are the most elementary data structure in R. All other structures (like the `data.table`) are constructed using these vectors. In R there is also no structure that is smaller than a vector. A single number is not treated differently from a numeric vector of length ten; In fact R sees the single number simply as a numeric vector of length 1. The `length()` of a vector can be obtained by using the function `length()`.

A vector can be created using the function `c()`. (The `c` stands for 'concatenate', 'coerce' or 'combine')

```{r}
c(1, 2, 3)
c('spam', 'ham', 'eggs')
c("double", "quotes", "work",
  'like', 'single')
c(TRUE, FALSE)
length(c(25, 4))
```

In the output we see that R shows the row number of the first element of each row between straight brackets. This makes it easier to refer to a particular element, especially when the vectors are long. We can work with vectors in the same way as with single numbers. In principle all operations are carried out in an element wise fashion.

```{r}
c(1, 2, 3) * c(4, 5, 6)
```

Note that when the lengths do not match they are **recycled**.
```{r}
c(1, 2, 3, 4) * c(4, 5)
# if the larger length is not an exact multiple
# of the smaller this often indicates a mistake
# and a warning is given
c(1, 2, 3) * c(4, 5) 
```

We can also give names to the elements of a vector:
```{r}
named_v <- c(foo=1, bar=2)
print(named_v)
mode(named_v)
class(named_v)
```
When we try to create a vector that consists of different data types they will be converted to a data type that is capable of containing all of them. For example: 

```{r}
c("eleven", 12)
```

The second element of the resulting vector is now also of type `character`. In general it is better not to trust this implicit conversion. Instead to it explicitly, in this case by using the function `as.character()`.

An other way to create a vector is by using the function `vector`. `vector('numeric', 8)` creates a numeric vector of length 8. The `vector` function is often used to pre-allocate room where the results of future computations can be stored. 



## Matrices
Vectors have just a single dimension (every element is characterized by a single number (index) that indicates its position within the vector). They can be generalized to vectors that are two dimensional, that is
they have both rows and columns. Like simple vectors all elements of a matrix have the same \emph{mode}.

```{r}
my_matrix <- matrix(data = c(1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
my_matrix

dim(my_matrix) # second dimension (# columns) is 1
matrix2 <- matrix(data = c(1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
                  nrow = 3)
matrix2
dim(matrix2)
char_mat <- matrix(data = c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'), nrow = 2)
class(char_mat)
mode(char_mat)
length(char_mat) #just counts the number of elements 
```

### Arrays
We do not have to stop with two dimensions. Arrays are even more general than matrices as they can have any number of dimensions. All elements have to be of the same type.

```{r}
letters[1:12]
my_array <- array(letters[1:12], c(2, 2, 3))
my_array
class(my_array)
mode(my_array)
```

## Lists

Elements of a vector, matrix or array are always of the same type. A `list` differs from a vector by also allowing its elements to be of a different type. We can make a `list` using the function `list`.

```{r}
list1 <- list("eleven", 12)
mode(list1)
class(list1)
list2 <- list(c(1, 2, 3), c('foo', 'bar'))
```
We can also assign a name to the elements of a list:

```{r}
list3 <- list(numbers=c(1, 2, 3), chars=c('foo', 'bar'))
```
It is also possible for a list to contain other lists.

```{r}
list4 <- list(numbers=c(1, 2, 3), chars=c('aap', 'noot'), 
               sublist=list(1,'a'))
```

A useful function for lists is `str`. It gives us its structure.
```{r}
str(list4)
```


### data.frames
This is a rectangular table in which every column contains a variable and every row an observation. They are similar to the spreadsheets: a
series, or `list` of equal length columns, or `vectors`. Notably, the columns (`vector`s) can be of different
classes, **unlike** a matrix or array. 

```{r}
my_df <- data.frame("vec" = c(12, 48), "lets" = letters[1:12])
my_df
dim(my_df)
class(my_df)
mode(my_df) # a data.frame is a special kind of list
str(my_df)
```

Most data sets come in the form of `data.frame`s or can be converted to them so we are going to see them frequently later in the course.

## factors

A `factor`is a special kind of vector for categorical data. The factor contains different integers one for every category. Each unique value has an associated 'label' that tell us what the code means. Factors are frequently used when we model categorical data. An advantage of a factor over a `character` is that we can limit the number of possible outcomes. It is also less likely to make mistakes due to typing errors.  Factors can be created by means of the function `factor()`.

```{r}
f <- c('male', 'female', 'male')
factor(f)
levels(f)
```

When a `factor` is displayed R also shows us the unique values the variable can take. These are called the 'levels' of the factor. 

## functions

Functions are used to do something. We have already seen several of them. 
Like `mode`, `class` and `as.integer` and you will see lots more. Note that in **R** functions are objects too.

```{r}
mode(mode)   # like all objects functions have a mode
class(mode)
print(mode)  
# do not worry if you do not understand the meaning of what is printed yet
```

Note that operators are functions to. When you want to use them in the same way as normal functions just put them between back-ticks ("`"):
```{r}
mode(`+`)   
`+`(1, 1)
```


Base **R** has many factions but many more are come from various extension packages. These can be installed using `install.packages()` :

```{r}
#| eval: false
install.packages("packageName",
                 lib = "/directory/to/my custom R library",
                 repos = "http://cran.xl-mirror.nl")

# usually lib and repos can be omitted (left at the default)
```

The package name must be quoted when installing.

```{r}
#| eval: false
library("packageName")      ## quotes are optional when loading a package
```

Functions will be discussed in more detail later.

## Missing values

Whenever the value of a variable is missing this is denoted by `NA` in R. Usually this means that the values exists however we do not know it. Sometimes the result of a calculation is not finite (for example when we define a positive or negative number by zero). In this case the result is defined to be `Inf` of `-Inf` in R.  When a value cannot be computed at all (for example when we divide zero by zero) R will define the result as `NaN`, which stands for 'Not a Number'. Finally, R sometimes uses the special value `NULL` to indicate that a variable is not yet defined. Here we will mostly deal with data that is just missing, that is  `NA`.

```{r}
a <- c(1, -1, 0, NA, NULL)
a/0
is.na(a)
is.finite(a)
is.null(a) # note this looks at the whole object
l <- list(foo= a, b=c('b'))
l[1] <- NULL # deletes elements from a list
l

```


## Saving and restoring your session

Because the typical way of using `R` involves writing text into a
file with the `.r` or `.R` extension it's natural to save your
commands written for a specific purpose in this `my-r-file.r`. Hopefully you're doing this right now. However there
are other bits and pieces of your `R` session described below you
may want or need to save.

Save all objects to the working directory in a file called `.RData`:
```{r}
#| eval: false
save.image()
``` 
Or give the file a name:
```{r}
#| eval: false
save.image("mySession.RData") 
``` 

Save all commands entered into the `R` console during your session to
the working directory in a file called `.Rhistory`: 
```{r}
#| eval: false
savehistory()
```
Such a file may be hidden by default in some file browsers, including linux.

Note that this typically occurs (console dependent) by default when you
quit your `R` session. If an `.Rhistory` file already exists from a previous
session, the current session is appended to the end of this file and
saved. Thus, by design, a complete log of your work is saved together
with your script file, if your console session contains less than 512 lines.

Save specific objects:
```{r}
#| eval: false
save(object_1, object_2, object_3, file = "rObjects123.RData")
```

Restore or load previous sessions or objects:
```{r}
#| eval: false
load("mySession.RData")        # load from the working directory
```

When you save and load objects this way, loaded variables will have the same names as when they were stored. There is also a different way of saving objects where loaded objects are assigned explicitly.

```{r}
myobject <- list(vec=c(1, 2, 3), mat=matrix(1:4,2))
saveRDS(myobject,file = 'myfile.rds')
object2 <- readRDS('myfile.rds')
identical(myobject, object2)
```


Load `.Rhistory` file to access the history from the console:
```{r}
#| eval: false
loadhistory()
```


## Miscellaneous Tips

`R` is case sensitive:
```{r}
c("Hello" == "hello", "goodbye" == "goodbye")
```

And is \emph{very} sensitive in general:
```{r}
#| eval: false
#| echo: true
# c("Hello" == "hello" "goodbye" == "goodbye") # not run
```


Missing data. `NA` 'Not Available' is how `R` defines a missing value
i.e., an empty cell in excel
```{r}
c(1, NA, 3, 4, NA)
``` 

`R` is an environment. What's in yours?
```{r}
#| eval: false
ls()                              # global environment
objects()                         # alias for ls()
```

Too many objects cluttering up your environment and computer memory?
Remove the ones you don't need:
```{r}
#| eval: false
rm(object_name)
```

What is the current \emph{working directory} where files are saved and loaded from by default?
```{r}
#| eval: false
getwd()
```

Need to set or change the current working directory?
```{r}
#| eval: false
setwd(dir = "c:\\Windows\\Users\\karl\\My Documents\\R stuff")
setwd(dir = "c:/Windows/Users/karl/My Documents/R stuff")
```
Note the double backslashes required by `R` running under
Windows. Single forward slashes, the Unix convention works equivalently.

Also be aware that if you started your `R` session by double
clicking a `file.name.r` file, by design the directory where this
file resides is set as the working directory. This directory is also a
good place, and the default place, to store the respective `.RData` and `.Rhistory` files if you have any. When these
files are present in the same directory they will be loaded
automatically, unless you explicitly tell `R` not to load them by
using the ` ---no-restore-data` argument when starting `R`.

Quit your `R` session:
```{r}
#| eval: false
q()                           # not run
```

Object names can not begin with numbers. For example:
```{r}
#| eval: false
## 3vector <- c(2, 4, 6))    # not run
```
But can end with numbers if necessary:
```{r}
vector3 <- c(2, 4, 6)
```

Try to code with style, for example:

<https://google.github.io/styleguide/Rguide.xml>

<http://adv-r.had.co.nz/Style.html>
